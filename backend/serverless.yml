service: emojiplace-backend

package:
  individually: true
  excludeDevDependencies: true

provider:
  name: aws
  runtime: nodejs18.x # Using a recent, stable Node.js runtime
  region: us-west-1
  stage: ${opt:stage, 'dev'}
  profile: default # Using your 'default' AWS CLI profile
  timeout: 29 # Best practice: Lambda timeout slightly less than API Gateway's 30s max.
  versionFunctions: true # Required for provisioned concurrency

  # Provider-level configuration for httpApi to enable CORS for all functions
  httpApi:
    cors: true

  # Environment variables that will be available to all your Lambda functions
  environment:
    REDIS_HOST: 'master.emojiplace-redis-cluster.4aarkn.usw1.cache.amazonaws.com'
    REDIS_PORT: 6379
    DYNAMODB_PIXEL_TABLE: PixelTable-${self:provider.stage} # Add table name for our functions
    # This will be automatically set by the framework after deployment
    WEBSOCKET_API_ENDPOINT:
      Fn::Join:
        - ""
        - - "https://"
          - !Ref WebsocketsApi
          - ".execute-api.us-west-1.amazonaws.com/"
          - ${self:provider.stage}

  # VPC configuration to allow Lambda to connect to ElastiCache
  vpc:
    securityGroupIds:
      # This needs to be the actual ID of the security group, not the name.
      # You can find this in the AWS VPC Console under "Security Groups".
      # It will look like 'sg-0123456789abcdef0'.
      - 'sg-005e6de7afff73792'
    subnetIds:
      # These need to be the actual IDs of the subnets you chose for your
      # ElastiCache subnet group. You can find these in the AWS VPC Console
      # under "Subnets". They will look like 'subnet-0123456789abcdef0'.
      - 'subnet-8cb874eb'
      - 'subnet-953b29cd'
      # Add more if you used more than two subnets

  # IAM permissions for your Lambda functions.
  iam:
    role:
      statements:
        - Effect: "Allow"
          Action:
            - "logs:CreateLogGroup"
            - "logs:CreateLogStream"
            - "logs:PutLogEvents"
          Resource: "arn:aws:logs:*:*:*"
        # Add permission for Lambda to manage WebSocket connections
        - Effect: "Allow"
          Action:
            - "execute-api:ManageConnections"
          Resource:
            - "arn:aws:execute-api:*:*:**/@connections/*"
        # Add permissions for Lambda to operate within a VPC
        - Effect: "Allow"
          Action:
            - "ec2:CreateNetworkInterface"
            - "ec2:DescribeNetworkInterfaces"
            - "ec2:DeleteNetworkInterface"
          Resource: "*"
        # Add permissions for Lambda to access the DynamoDB table and its stream
        - Effect: "Allow"
          Action:
            - "dynamodb:Query"
            - "dynamodb:Scan"
            - "dynamodb:GetItem"
            - "dynamodb:PutItem"
            - "dynamodb:GetRecords"
            - "dynamodb:GetShardIterator"
            - "dynamodb:DescribeStream"
            - "dynamodb:ListStreams"
          Resource:
            - "arn:aws:dynamodb:${self:provider.region}:*:table/PixelTable-${self:provider.stage}"
            - "arn:aws:dynamodb:${self:provider.region}:*:table/PixelTable-${self:provider.stage}/stream/*"

functions:
  # We will define our HTTP API and WebSocket functions here.
  # For example, your GET /api/pixels/:x/:y route would look something like this:
  #
  # getPixel:
  #   handler: src/handlers/http.getPixel # Path: src/handlers/http.js, Function: getPixel
  #   events:
  #     - httpApi:
  #         path: /api/pixels/{x}/{y}
  #         method: get

  getPixel:
    handler: src/handlers.getPixel
    events:
      - httpApi:
          path: /api/pixels/{x}/{y}
          method: get
    provisionedConcurrency: 1

  getPixelRegion:
    handler: src/handlers.getPixelRegion
    events:
      - httpApi:
          path: /api/pixels/region/{x}/{y}/{width}/{height}
          method: get
    provisionedConcurrency: 1

  getUser:
    handler: src/handlers.getUser
    # This is a critical user-facing function that needs to be fast.
    events:
      - httpApi:
          path: /api/users/me
          method: get
    provisionedConcurrency: 1

  setUsername:
    handler: src/handlers.setUsername
    events:
      - httpApi:
          path: /api/users/username
          method: post
    provisionedConcurrency: 1
    # No provisioned concurrency needed for this less frequent action

  # WebSocket Handlers
  connectionHandler:
    handler: src/handlers.handleConnect
    events:
      - websocket:
          route: $connect
    provisionedConcurrency: 1

  disconnectionHandler:
    handler: src/handlers.handleDisconnect
    events:
      - websocket:
          route: $disconnect

  messageHandler:
    handler: src/handlers.handleMessage
    events:
      - websocket:
          route: $default
    provisionedConcurrency: 1

  snapshot:
    handler: src/snapshot.handler
    vpc: ${self:provider.vpc} # Needs VPC access to talk to Redis
    events:
      - schedule: rate(1 day)

# Define our DynamoDB table without the stream
resources:
  Resources:
    PixelTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.DYNAMODB_PIXEL_TABLE}
        AttributeDefinitions:
          - AttributeName: xy
            AttributeType: S
        KeySchema:
          - AttributeName: xy
            KeyType: HASH
        BillingMode: PAY_PER_REQUEST

    # VPC Endpoint for DynamoDB (Gateway Endpoint)
    # This allows Lambdas in the VPC to access DynamoDB without a NAT Gateway.
    DynamoDBVpcEndpoint:
      Type: AWS::EC2::VPCEndpoint
      Properties:
        # You can find your VPC ID in the AWS VPC Console. It's the VPC that
        # your subnets and security group belong to.
        VpcId: vpc-691e3e0d
        ServiceName: com.amazonaws.${self:provider.region}.dynamodb
        # You need to specify the route tables associated with your subnets.
        # Find these in the VPC console, under Route Tables.
        RouteTableIds:
          - rtb-c68e7da1

    # VPC Endpoint for API Gateway (Interface Endpoint)
    # This allows Lambdas to post back to WebSocket clients via the
    # execute-api without needing a NAT Gateway.
    ExecuteApiVpcEndpoint:
      Type: AWS::EC2::VPCEndpoint
      Properties:
        # You can find your VPC ID in the AWS VPC Console.
        VpcId: vpc-691e3e0d
        ServiceName: com.amazonaws.${self:provider.region}.execute-api
        VpcEndpointType: Interface
        SubnetIds: ${self:provider.vpc.subnetIds}
        SecurityGroupIds: ${self:provider.vpc.securityGroupIds}
        PrivateDnsEnabled: true

# We can add custom AWS resources here later, such as VPC and Security Group
# configurations needed for the ElastiCache instance.
# resources:
#   Resources:
#     ... 